#include "bootloader.h"
#include "ui_bootloader.h"
#include <QtSerialPort/QSerialPort>
#include <QtSerialPort/QSerialPortInfo>
#include <QStringList>
#include <iostream>
#include <QDebug>

Bootloader::Bootloader(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::Bootloader)
{
    ui->setupUi(this);

    QList<QSerialPortInfo> serial_list = QSerialPortInfo::availablePorts();
    for (auto iter = serial_list.begin(); iter != serial_list.end(); iter++)
        ui->label_detect->setText(iter->portName() + " (" + iter->description() + ")");

    this->Serial = new QSerialPort;
    this->Serial->setPortName("ttyUSB0");
    this->Serial->setBaudRate(QSerialPort::Baud57600);
    this->Serial->setDataBits(QSerialPort::Data8);
    this->Serial->setParity(QSerialPort::NoParity);
    this->Serial->setStopBits(QSerialPort::OneStop);
    this->Serial->setFlowControl(QSerialPort::NoFlowControl);

    if (this->Serial->open(QIODevice::ReadWrite)){
        std::cout << "OK" << std::endl;
    }
    else{
        std::cout << "NOT OK" << std::endl;
    }

    connect(this->Serial, &QSerialPort::readyRead, this, &Bootloader::PushDataFromStream);

    connect(ui->pushButton_ping,    &QPushButton::released, this, &Bootloader::C_Ping);
    connect(ui->pushButton_jump,    &QPushButton::released, this, &Bootloader::C_Jump);
    connect(ui->pushButton_erase,   &QPushButton::released, this, &Bootloader::C_Erase);
    connect(ui->pushButton_verify,  &QPushButton::released, this, &Bootloader::C_Verify);
    connect(ui->pushButton_read,    &QPushButton::released, this, &Bootloader::C_Read);
    connect(ui->pushButton_write,   &QPushButton::released, this, &Bootloader::C_Write);

    this->UIUnlock(true);
}

Bootloader::~Bootloader()
{
    delete this->Serial;
    delete ui;
}

void Bootloader::C_Ping(void){
    ConsoleBasic("Ping");
    MsgHeader header(this->PING, 0);

    this->data_awaited = this->PING_AWAIT_SIZE;
    this->Serial->write(header.SetRawFromHeader());
}

void Bootloader::C_Erase(void){
    ConsoleBasic("Erase");
    MsgHeader header(this->ERASE, )
}

void Bootloader::C_Jump(void){
    ConsoleBasic("Jump");
}

void Bootloader::C_Read(void){
    ConsoleBasic("Reading From");
}

void Bootloader::C_Verify(void){
    ConsoleBasic("Firmware Verification Started");
}

void Bootloader::C_Write(void){
    ConsoleBasic("Write Firmware Started");
}

void Bootloader::ProcessIncomingData(void){
    QByteArray data = this->Serial->read(this->data_awaited);
    this->data_awaited = 0;
    this->Serial->readAll();

    MsgHeader header;
    header.SetHeaderFromRaw(data);
    std::cout << header.cmd << " " << header.w_size << std::endl;
    uint32_t id = header.payload[0];
    std::cout << (uint8_t)(id) << (uint8_t)(id >> 8) << (uint8_t)(id >> 16) << (uint8_t)(id >> 24) << std::endl;
}

void Bootloader::ErrorCatch(uint32_t error_code){
    std::cout << "Error Code" << error_code << std::endl;
}

void Bootloader::UIUnlock(bool lock){
    ui->pushButton_choosefile->setEnabled(lock);
    ui->pushButton_erase->setEnabled(lock);
    ui->pushButton_jump->setEnabled(lock);
    ui->pushButton_ping->setEnabled(lock);
    ui->pushButton_read->setEnabled(lock);
    ui->pushButton_verify->setEnabled(lock);
    ui->pushButton_write->setEnabled(lock);
}

void Bootloader::PushDataFromStream(void){
    qDebug() << this->Serial->bytesAvailable();
    if ((this->data_awaited) && (this->Serial->bytesAvailable() >= this->data_awaited))
        this->ProcessIncomingData();
}

void Bootloader::ConsoleBasic(QString message){
    ui->listWidget_debugconsole->addItem("[INFO] " + message);
}

void Bootloader::ConsoleError(QString message){
    ui->listWidget_debugconsole->addItem("[WARNING] " + message);
    ui->listWidget_debugconsole->item(ui->listWidget_debugconsole->count() - 1)->setForeground(QColor(219, 169, 0));
}

void Bootloader::ConsoleWarning(QString message){
    ui->listWidget_debugconsole->addItem("[ERROR] " + message);
    ui->listWidget_debugconsole->item(ui->listWidget_debugconsole->count() - 1)->setForeground(QColor(208, 51, 51));
}
